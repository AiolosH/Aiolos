---
title: 排序算法
description: 数据结构
date: 2020-01-01 00:00:00 +08:00
tags: 数据结构
category: 数据结构
---

# 排序算法

## 内排序
待排序记录存放在计算机随机存储器中（比如内存）进行的排序过程。
## 外排序
待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。这些数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

## 衡量效率的方法
内部排序：比较次数，也就是<u><b>时间复杂度</u></b>  
外部排序：IO次数，也就是<u><b>读写外存的次数</u></b>  

- | 时间复杂度 | 空间复杂度 | 稳定性 | 复杂性 
- | - | - | - | -
插入排序 | 平均O(n^2) 最坏O(n^2) 最好 O(n) | O(1) | 稳定 | 简单
希尔排序 | 平均O(n^1.3)  | O(1) | 不稳定 | 较复杂
冒泡排序 | 平均O(n^2) 最坏O(n^2) 最好 O(n) | O(1) | 稳定 | 简单
快速排序 | 平均O(nlog2n) 最坏O(n^2) 最好 O(nlog2n) | O(nlog2n) | 不稳定 | 较复杂
直接选择排序 | 平均O(n^2) 最坏O(n^2) 最好 O(n^2) | O(1) | 不稳定 | 简单
堆排序 | 平均O(nlog2n) 最坏O(nlog2n) 最好 O(nlog2n) | O(1) | 不稳定 | 较复杂
归并排序 | 平均O(nlog2n) 最坏O(nlog2n) 最好 O(nlog2n) | O(n) | 稳定 | 较复杂

简单排序 时间复杂度为O(n^2) 插入排序，冒泡排序，直接选择排序

## 排序的稳定性 
判断排序算法是否稳定, 排序之后相同关键字的元素之间的相对次序是否保持不变。
保持不变则说明该算法稳定, 反之则是不稳定的。

确定是否为稳定算法还需要根据具体算法确定

## 插入排序

插入排序算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序

### 直接插入排序
``` C++
void InsertSort(int R[], int n)
{
	int i, j;
	int tmp;
	for (i = 1; i < n; i++)
	{
		tmp = R[i]; // 从第二个开始排
		j = i - 1;  
		while (j >= 0 && R[j] > tmp) // 循环向前比较
		{
			R[j + 1] = R[j];
			j--;
		}
		R[j + 1] = tmp;
	}
}
```

#### 分析 时间复杂度
最优情况 正序(1,2,3,4,5) 只需要进行for循环 循环了n-1次
最坏情况 倒序(5,4,3,2,1) 外循环需要执行 n-1 次，内循环需要执行 n次

#### 分析 空间复杂度
O(1)

#### 分析 稳定性

上述算法为稳定算法，做如下修改即为不稳定算法
``` C++
//while (j >= 0 && R[j] > tmp) 
while (j >= 0 && R[j] >= tmp)
```
若while结束前的序列...,A1,A2,.... 且A1 == A2, 遇到这个情况，会继续交换一次, 结束的序列...,A2,A1,....所以变成不稳定

### 折半插入排序
``` C++
void InsertSort(int R[], int n)
{
	int i, j, low, high, mid;
	int tmp;
	for (i = 1; i < n; i++)
	{
		tmp = R[i]; // 从第二个开始排
		low = 0; high = i - 1;  
		while (high >= low) // 在R[low, high]中折半查找有序插入的位置
		{
			mid = (low + high) / 2;     // 取中间位置
            if (R[mid] > tmp)       // 寻找tmp插入的位置
                high = mid - 1;     // 插入点在左半区
            else
                low = mid + 1;  // 插入点在右半区
		}
        for (j = i - 1; j >= high + 1; j--)
            R[j + 1] = R[j];
		R[high + 1] = tmp;      // 插入
	}
}
```
每次while循环就会出现一个<u><b>局部有序的区域</u></b>，之后的每个数据在这个局部有序区中插入
#### 分析 时间复杂度


#### 分析 空间复杂度
O(1)

#### 分析 稳定性
上述算法为稳定算法，做如下修改即为不稳定算法
``` C++
//if (R[mid] > tmp)       // 寻找tmp插入的位置
if (R[mid] >= tmp)       // 寻找tmp插入的位置
```

### 两种插入排序的比较
折半插入排序主要是用二分法加快了找插入点的效率


## 希尔排序
``` C++
void ShellSort(int R[], int n)
{
	int i, j, gap;
	int tmp;
	gap = n / 2;	//增量初值
	while (gap > 0)
	{
		for (i = gap; i < n; i++)	//对所有像个gap位置的元素组采用直接插入排序
		{
			tmp = R[i];
			j = i - gap;
			while(j >= 0 && tmp < R[j])	// 对相隔gap位置的元素组进行排序
			{ 
				R[j + gap] = R[j];
				j = j - gap;
			}
			R[j + gap] = tmp;
		}
		gap = gap / 2;	// 减下增量
	}
}
```

## 冒泡排序
``` C++
void BubbleSort(int R[], int n)
{
	int i, j;
	int tmp;
	for (i = 0; i < n - 1; i++)
	{
		for (j = n - 1; j > i; j--)
		{
			if (R[j -1] > R[j])	// 比较，找出本趟关键词的最小元素
			{
				tmp = R[j];		// R[j]与R[j-1]进行交换，将关键词最小的元素前移
				R[j] = R[j - 1];
				R[j - 1] = tmp;
			}
		}
	}
}
```
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

#### 分析 时间复杂度


#### 分析 空间复杂度
O(1)

#### 分析 稳定性
上述算法为稳定算法，做如下修改即为不稳定算法
``` C++
// if (R[j- 1] > R[j])      // 比较，找出本趟关键词的最小元素
if (R[j- 1] >= R[j])      // 比较，找出本趟关键词的最小元素
```

## 快速排序
``` C++
void QuickSort(int R[], int s, int t) // 对 R[s] 到R[t]的元素进行排序
{
	int i = s, j = t;
	int tmp;
	if (s < t)
	{
		tmp = R[s];
		while (i != j)
		{
			while (j > i && R[j] >= tmp)    // 尾部的数据和当前需要归位的元素比较
			{
				j -- ;
			}
			R[i] = R[j];

			while (i < j && tmp >= R[i])    // 头部的数据和当前需要归为的元素比较
			{
				i ++;
			}
			R[j] = R[i];
		}
		R[i] = tmp;

		QuickSort(R, s, i - 1);			// 对左区间递归排序
		QuickSort(R, i + 1, t);			// 对右区间递归排序
	}
}
```

## 直接选择排序
``` C++
void SelectSort(int R[], int n)
{
	int i, j, k;
	int tmp;
	for (i = 0; i < n - 1; i++)			// 做第i趟排序
	{
		k = i;

		for (j = i + 1; j < n; j++)		// 在当前无序区R[i, ... ，n-1]中选最小的R[k]
		{
			if (R[j] < R[k])
			{
				k = j;  // K记录目前找到的最小关键字所在的位置
			}
		}

		if (k != i)	    // 交换R[i]和R[K]
		{
			tmp = R[i];
			R[i] = R[k];
			R[k] = tmp;
		}
	}
}
```

## 堆排序

## 归并排序

- 哨兵简化编程的处理技巧