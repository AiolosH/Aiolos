---
title: 内存四区
description: wait
date: 2020-01-01 00:00:00 +08:00
tags: wait
category: wait
---

# 静态区域与动态区域

## 静态区域
text segment(代码段): 包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许自修改程序。 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

data segment(数据段): 存储程序中已初始化的全局变量和静态变量

bss segment(BSS段)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

## 动态区域

heap（堆区）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。

memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）

stack（栈区）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。


# 内存四区

### 栈区(stack)
就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。

### 堆区(heap)
一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。

- 堆：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。

- 自由存储区：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。

### 数据区
主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。

- 全局区&静态区：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为

- 全局初始化区(DATA段) ：存储程序中已初始化的全局变量和静态变量

- 未初始化段(BSS段) ：存储<u><b>未初始化</b></u>的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的另一块区域。

    BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。

　　在 C++ 里面没有这个区分了，他们共同占用同一块内存区。


### 代码区
包括只读存储区和文本区，其中只读存储区存储字符串常量，就是常量区，文本区存储程序的机器代码


## 可执行程序包括
可执行程序包括BSS段、数据段、代码段（也称文本段）
